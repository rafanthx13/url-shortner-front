npx cypress open

no window foi necessario fazer isso
 .\node_modules\.bin\cypress.cmd install

cypress.json

{
	"baseUrl": "http://localhost:8080"
}

////

package.json
npm cypress run
npx cypress open
================

COmandos uteis

cy.wait(2000) // spere
==================
context('name context', () =:{

// um context tem varios It, em geral cada context éuma pagina e cada it é uma açao possivel na pagina



}

========

FOrmas de get: sleeciona um elemetnom da dom

cy.get('input[data-cy="nome"]')

cy.get('input[data-cy="nome"]').focus().type('Patrick')

=======

Como usar no vue

data-cy nos componetnts: No quasar e em vários framweoks de CSS, cada elemento do UI é encapsuladao. ENtoa, para fazer o testes, é encessaŕio por tags para especificar melhor, por isso, coloca-se como no exmeplo abaix

<q-input outlined clearable lazy-rules v-model="field" clear-icon="close" label="Field" data-cy="field" />

y.get('[data-cy=field]').type('some value here').should('have.value', 'some value here')


============

https://github.com/patrickmonteiro/quasar-cypress/blob/master/cypress/integration/CadastraUsuario.spec.js


context('Cadastro de Usuário', () => {
  // beforeEach(() => {
  //   cy.visit('/usuario')
  //   cy.wait(2000)
  // })

  it('Acesso Usuários', () => {
    cy.visit('/usuario')
    cy.wait(2000)
  })

  it('Preenche Campo Nome', () => {
    cy.get('input[data-cy="nome"]').focus().type('Patrick')
  })

  it('Preenche Campo Sobrenome',  () => {
    cy.get('input[data-cy="sobrenome"]').focus().type('Monteiro')
  })

  it('Preenche Campo CPF',  () => {
    cy.get('input[data-cy="cpf"]').focus().type('00700800910')
  })

  it('Preenche Campo Endereço', () => {
    cy.get('input[data-cy="endereco"]').focus().type('Rua Duque de Caxias 555')
  })

  it('Seleciono o Gênero', () => {
    cy.get('[data-cy="genero"]').click()
    cy.wait(500)
    cy.get('div.q-item-division').contains('Masculino').click()
    // cy.get('div[link=true]').eq(1).click()
  })

  it('Seleciono o Idioma', () => {
    cy.get('div[data-cy="idioma"] button').contains('Português').click()
    cy.wait(1000)
    // cy.get('div.q-item-division').contains('Masculino').click()
    // cy.get('div[link=true]').eq(1).click()
  })

  it('Clica no Botão Confirmar', () => {
    cy.get('button[data-cy="salvarUsuario"]').click()
  })

  it('Aguardo 1 Segundo', () => {
    cy.wait(500)
    cy.get('[data-cy="msg-success"]').scrollIntoView()
    cy.wait(500)
  })

  it('Verifico mensagem de confirmação', () => {
    cy.get('span[data-cy="alert-sucesso"]').contains("Usuário cadastrado com sucesso")
  })

})

type: inserre lgo no campo

click() clica no botao

============

DOCUMENTAAÇO OFICIAL

touch cypress/integration/home_page_spec.js

=========

O que se pode sar de avanaçado no cypress

While there is a lot more to this strategy, you generally have three ways to facilitate this with Cypress:

cy.exec() - to run system commands
cy.task() - to run code in Node via the pluginsFile
cy.request() - to make HTTP requests

### exec


describe('The Home Page', () => {
  beforeEach(() => {
    // reset and seed the database prior to every test
    cy.exec('npm run db:reset && npm run db:seed')
  })

  it('successfully loads', () => {
    cy.visit('/')
  })
})

### BeforeEach

describe('The Home Page', () => {
  beforeEach(() => {
    // reset and seed the database prior to every test
    cy.exec('npm run db:reset && npm run db:seed')

    // seed a post in the DB that we control from our tests
    cy.request('POST', '/test/seed/post', {
      title: 'First Post',
      authorId: 1,
      body: '...',
    })

    // seed a user in the DB that we can control from our tests
    cy.request('POST', '/test/seed/user', { name: 'Jane' })
      .its('body')
      .as('currentUser')
  })

  it('successfully loads', () => {
    // this.currentUser will now point to the response
    // body of the cy.request() that we could use
    // to log in or work with in some way

    cy.visit('/')
  })
})

### Login :: Buscando cookie

describe('The Login Page', () => {
  beforeEach(() => {
    // reset and seed the database prior to every test
    cy.exec('npm run db:reset && npm run db:seed')

    // seed a user in the DB that we can control from our tests
    // assuming it generates a random password for us
    cy.request('POST', '/test/seed/user', { username: 'jane.lane' })
      .its('body')
      .as('currentUser')
  })

  it('sets auth cookie when logging in via form submission', function () {
    // destructuring assignment of the this.currentUser object
    const { username, password } = this.currentUser

    cy.visit('/login')

    cy.get('input[name=username]').type(username)

    // {enter} causes the form to submit
    cy.get('input[name=password]').type(`${password}{enter}`)

    // we should be redirected to /dashboard
    cy.url().should('include', '/dashboard')

    // our auth cookie should be present
    cy.getCookie('your-session-cookie').should('exist')

    // UI should reflect this user being logged in
    cy.get('h1').should('contain', 'jane.lane')
  })
})

outr exemplo

describe('The Dashboard Page', () => {
  beforeEach(() => {
    // reset and seed the database prior to every test
    cy.exec('npm run db:reset && npm run db:seed')

    // seed a user in the DB that we can control from our tests
    // assuming it generates a random password for us
    cy.request('POST', '/test/seed/user', { username: 'jane.lane' })
      .its('body')
      .as('currentUser')
  })

  it('logs in programmatically without using the UI', function () {
    // destructuring assignment of the this.currentUser object
    const { username, password } = this.currentUser

    // programmatically log us in without needing the UI
    cy.request('POST', '/login', {
      username,
      password,
    })

    // now that we're logged in, we can visit
    // any kind of restricted route!
    cy.visit('/dashboard')

    // our auth cookie should be present
    cy.getCookie('your-session-cookie').should('exist')

    // UI should reflect this user being logged in
    cy.get('h1').should('contain', 'jane.lane')
  })
})

======

traballhar com env

https://docs.cypress.io/guides/guides/environment-variables#Option-2-cypress-env-json

=======

traduçao de singifivado

After clicking on this <button>, I expect its class to eventually be active.
cy.get('button').click().should('have.class', 'active')

After making an HTTP request to my server, I expect the response body to equal {name: 'Jane'}
cy.request('/users/1').its('body').should('deep.eq', { name: 'Jane' })]


cy.visit('/home')
cy.get('.main-menu').contains('New Project').click()
cy.get('.title').type('My Awesome Project')
cy.get('form').submit()
Without a single explicit assertion, there are dozens of ways this test can fail! Here's a few:

The initial cy.visit() could respond with something other than success.
Any of the cy.get() commands could fail to find their elements in the DOM.
The element we want to .click() on could be covered by another element.
The input we want to .type() into could be disabled.
Form submission could result in a non-success status code.
The in-page JS (the application under test) could throw an error.

it('changes the URL when "awesome" is clicked', () => {
  cy.visit('/my/resource/path') // 1.

  cy.get('.awesome-selector') // 2.
    .click() // 3.

  cy.url() // 4.
    .should('include', '/my/resource/path#awesomeness') // 5.
})
The test above would cause an execution in this order:

Visit a URL.
Find an element by its selector.
Perform a click action on that element.
Grab the URL.
Assert the URL to include a specific string.
These actions will always happen serially (one after the other), never in parallel (at the same time). Why?

To illustrate this, let's revisit that list of actions and expose some of the hidden ✨ magic ✨ Cypress does for us at each step:

Visit a URL ✨ and wait for the page load event to fire after all external resources have loaded✨
Find an element by its selector ✨ and retry until it is found in the DOM ✨
Perform a click action on that element ✨ after we wait for the element to reach an actionable state ✨
Grab the URL and...
Assert the URL to include a specific string ✨ and retry until the assertion passes ✨
As you can see, Cypress does a lot of extra work to ensure the state of the application matches what our commands expect about it. Each command may resolve quickly (so fast you won't see them in a pending state) but others may take seconds, or even dozens of seconds to resolve.

While most commands time out after a few seconds, other specialized commands that expect particular things to take much longer like cy.visit() will naturally wait longer before timing out.





========


Writing Assertions
There are two ways to write assertions in Cypress:
1. Implicit Subjects: Using .should() or .and().
2. Explicit Subjects: Using expect.

Anad é apra adicionar mais shoulds

cy.get('#header a')
  .should('have.class', 'active')
  .and('have.attr', 'href', '/users')

=========

mudanddo timeout

// we've modified the timeout which affects default
// plus all added assertions
cy.get('.mobile-nav', { timeout: 10000 })
  .should('be.visible')
  .and('contain', 'Home')

========= Comand-==============


cy.visit() loads a remote page and does not resolve until all of the external resources complete their loading phase. This may take awhile, so its default timeout is set to 60000ms.
cy.exec() runs a system command such as seeding a database. We expect this to potentially take a long time, and its default timeout is set to 60000ms.
cy.wait() actually uses 2 different timeouts. When waiting for a routing alias, we wait for a matching request for 5000ms, and then additionally for the server's response for 30000ms. We expect your application to make a matching request quickly, but we expect the server's response to potentially take much longer.

cy.visit() expects the page to send text/html content with a 200 status code.
cy.request() expects the remote server to exist and provide a response.
cy.contains() expects the element with content to eventually exist in the DOM.
cy.get() expects the element to eventually exist in the DOM.
.find() also expects the element to eventually exist in the DOM.
.type() expects the element to eventually be in a typeable state.
.click() expects the element to eventually be in an actionable state.
.its() expects to eventually find a property on the current subject.

cy.request() automatically gets + sets cookies to and from the remote server.
cy.clearCookies() clears all of the browser cookies.
.click() causes your application to react to click events.

log
cy.log('I run before every test in every spec file!!!!!!')
